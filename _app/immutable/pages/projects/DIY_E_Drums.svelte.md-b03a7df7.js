import{S as pa,i as ua,s as ha,e as o,t as i,k as u,w as cs,c as n,a as l,h as r,d as t,m as h,x as ds,b as c,U as C,g as p,K as s,y as ms,E as ca,q as fs,o as gs,B as bs}from"../../chunks/index-959e8fc0.js";import{C as aa}from"../../chunks/prism-c-a8466d46.js";import{Y as da}from"../../chunks/YouTube-5bb2733c.js";import"../../chunks/prism-a46989fb.js";import"../../chunks/Notification-45fcd0f6.js";import"../../chunks/index-faaff173.js";import"../../chunks/ripple-8363dcce.js";/* empty css                                                            */function ma(oa){let m,nt,oe,it,rt,T,lt,pt,De,H,x,ks,Pe,f,ut,ne,ht,ct,ie,dt,mt,Te,$,F,vs,Ae,k,ft,re,gt,bt,Me,v,le,kt,vt,pe,yt,Oe,y,wt,A,_t,It,Se,G,Y,ys,Le,w,Et,ue,Dt,Pt,qe,d,z,he,Tt,At,Mt,j,ce,Ot,St,Lt,V,de,qt,Ct,Ht,_,me,xt,$t,fe,Ft,Gt,Yt,I,ge,zt,jt,be,Vt,Rt,Ce,E,Nt,ke,Jt,Xt,He,M,xe,O,na=`<code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sample <span class="token operator">></span> PAD_SAMPLE<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sample <span class="token operator">></span> THRESHOLD<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                            <span class="token punctuation">(</span>time <span class="token operator">-</span> PAD_HOLDOFF<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> HOLDOFF<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  PAD_ACTIVE<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
  PAD_HOLDOFF<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,$e,g,Bt,ve,Wt,Ut,ye,Kt,Qt,Fe,S,Ge,L,ia=`<code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PAD_ACTIVE<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>sample <span class="token operator">&lt;</span> PAD_SAMPLE<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> velocity <span class="token operator">=</span> <span class="token punctuation">(</span>sample <span class="token operator">-</span> HOLDOFF<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">127</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">4095</span> <span class="token operator">-</span> HOLDOFF<span class="token punctuation">)</span><span class="token punctuation">;</span>
  MIDI<span class="token punctuation">.</span><span class="token function">sendNoteOn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> PAD_NOTES<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> velocity<span class="token punctuation">)</span><span class="token punctuation">;</span>
  PAD_ACTIVE<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
  MIDI<span class="token punctuation">.</span><span class="token function">sendNoteOff</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> PAD_NOTES<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Ye,R,N,ws,ze,J,Zt,je,D,es,we,ts,ss,Ve,X,B,_s,Re,W,U,Is,Ne,K,as,Je,Q,os,Xe,Z,ee,Es,Be,te,ns,We,P,is,_e,rs,ls,Ue,q,Ke;return M=new aa({}),S=new aa({}),q=new da({props:{src:"https://www.youtube.com/embed/Yf2NzRww4Mk"}}),{c(){m=o("p"),nt=i("For a while I have window shopping for a drum sampling pad - in particular the ubiquitous "),oe=o("em"),it=i("Roland SPD SX"),rt=i(` (see picture below). However for the light use I will likely get out of a pad set, I can\u2019t really justify the high price for a proper set. So instead, I thought I\u2019d try to make my own!
These DIY drums don\u2019t have any form of sampling capabilities or sound-generation: they only output MIDI. This doesn\u2019t bother me, as all of my drum rack samples are generated in Ableton, however if you wanted to add inbuilt sampling/sound generation there are many Raspberry Pi based projects designed for this task. `),T=o("a"),lt=i("This one"),pt=i(" is relatively straightforward to build and interface with a MIDI input."),De=u(),H=o("p"),x=o("img"),Pe=u(),f=o("p"),ut=i("The first and probably most crucial step of the E-Drum creation is to make the piezo pads themselves. There is a wealth of information on the subject online, however most of the similar builds that I found had the pads completely separate from one another. For an "),ne=o("em"),ht=i("SPD SX"),ct=i("-style design with all the pads mounted on the same surface in close proximity to one another, crosstalk becomes a major concern. Diagnosing "),ie=o("em"),dt=i("crosstalk"),mt=i(" through serial and MIDI messages is fairly tiresome, but thankfully I now have an oscilloscope! Below is a picture of me testing a commercial pad (origin unknown) against my homemade pads. Interestingly enough the Piezos behave quite differently when struck with Hot Rods compared to regular wooden sticks."),Te=u(),$=o("p"),F=o("img"),Ae=u(),k=o("p"),ft=i("The input that the STM32 \u2018sees\u2019 looks something like the oscilloscope capture shown below: Note that my hardware does not have any input filtering, only a 1M\u2126 resistor and a reverse-biased 3.3V zener diode across the output of each Piezo. The resistor helps clamp down the noise on the analogue input when the piezo is not struck , while the zener diode simply stops the voltage on the analog input straying outside "),re=o("code"),gt=i("-0.7V -> 3.3V"),bt=i(", protecting the microcontroller hardware. The lack of any filtering means two things:"),Me=u(),v=o("ul"),le=o("li"),kt=i("We need to sample the input at a frequency that is an order of magnitude higher than the resonant freqency of the pads (this avoids missing the samples or recording inaccurate velocities)."),vt=u(),pe=o("li"),yt=i("The peak detection has to be done in software, without misidentifying retriggers or \u2018ghost notes\u2019."),Oe=u(),y=o("p"),wt=i("The algorithm I used for processing the signal is very simple, and has plenty of room for optimisation, but it works surprisingly well. If you are interested in a superior hardware approach to processing the piezo signals, I would recommend reading "),A=o("a"),_t=i("this article"),It=i("."),Se=u(),G=o("p"),Y=o("img"),Le=u(),w=o("p"),Et=i("The algorithm loops through each input, reading the analogue value to a variable called "),ue=o("code"),Dt=i("sample"),Pt=i(". Each input has 5 global variables (stored in an array):"),qe=u(),d=o("ul"),z=o("li"),he=o("code"),Tt=i("PAD_NOTES[10]"),At=i(" - contains each input\u2019s MIDI note value."),Mt=u(),j=o("li"),ce=o("code"),Ot=i("PAD_PINS[10]"),St=i(" - contains the pin macro mapping the input to the physical pin that has to be read."),Lt=u(),V=o("li"),de=o("code"),qt=i("PAD_ACTIVE[10]"),Ct=i(" - a boolean representing whether the input is \u2018ACTIVE\u2019 or not: (triggered when threshold is exceeded)."),Ht=u(),_=o("li"),me=o("code"),xt=i("PAD_SAMPLE_[10]"),$t=i(" - a buffer of the previous "),fe=o("code"),Ft=i("sample"),Gt=i(" value for each input."),Yt=u(),I=o("li"),ge=o("code"),zt=i("PAD_HOLDOFF[10]"),jt=i(" - a timestamp (from "),be=o("code"),Vt=i("millis()"),Rt=i(") indicating when the input becomes \u2018ACTIVE\u2019."),Ce=u(),E=o("p"),Nt=i("The processing is split into two stages: the first stage is to check when the input exceeds a certain \u2018Threshold\u2019. This threshold is globally defined and is set slightly higher than the noise floor of the piezos and any light crosstalk. Once a particular input exceeds this threshold, it is marked as \u2018ACTIVE\u2019, and the "),ke=o("code"),Jt=i("PAD_HOLDOFF[i]"),Xt=i(" is set as the current timestamp [see code snippet below]. However, the pad can\u2019t be set high unless a certain \u2018Holdoff\u2019 period has elapsed. This is a global variable that defines the minimum time between two consecutive triggers. It should be set short enough to allow for fast drum rolls, but long enough to prevent the trigger \u2018bouncing\u2019."),He=u(),cs(M.$$.fragment),xe=u(),O=o("pre"),$e=u(),g=o("p"),Bt=i("Once the channel has been marked as active, we can\u2019t immediately send the MIDI note, as the sample that is measured when an input exceeds the \u2018Threshold\u2019 does not give us any real knowledge of the "),ve=o("em"),Wt=i("velocity"),Ut=i(" of the drum strike. There are a multitude of methods of processing the input signal to derive a velocity, but the one I like the best is to wait until the most recent input sample is less than the previous sample (i.e. the first local peak has been reached). We then work out the velocity by multiplying the 12-bit anologue input value by 127 and divide through by the \u2018working range\u2019 of the ADC "),ye=o("em"),Kt=i("(2^12 - Threshold)"),Qt=i(". This method doesn\u2019t work that well for really soft notes, but it doesn\u2019t involve any averaging or arbitrary delays, so the pads feel really responsive! The fact that the code in its entirety is not much more than these two snippets makes it quite easy to make a drum set with lots of pads and very low latency."),Fe=u(),cs(S.$$.fragment),Ge=u(),L=o("pre"),Ye=u(),R=o("p"),N=o("img"),ze=u(),J=o("p"),Zt=i("The hardware (pictured above) is equally minimal. I was considering adding some LEDs and buttons to the unit, but considering it will never be more than 2 metres from my computer I decided against it. The drums have no onboard controls - everything is done over MIDI."),je=u(),D=o("p"),es=i("The casing is actually a cut-down section of an old Strand LX analogue lighting console I managed to scavenge from a school clear-out. It is already shaped a bit like an "),we=o("em"),ts=i("SPD SX"),ss=i(", and it is almost indestructible! It also has 1.6mm grooves built into the extrusion, so mounting my perfboard controller inside was a breeze. I added an extra serial header that outputs serial MIDI, in case I want to add a raspberry Pi as an onboard sound module at some point in the future."),Ve=u(),X=o("p"),B=o("img"),Re=u(),W=o("p"),U=o("img"),Ne=u(),K=o("p"),as=i("The pads are constructed from some scrap angle iron which have rubber/fabric mouse mats epoxied onto the top surface. The thicker-than-ideal metal makes the pads feel a bit less like a drum that I would have liked, but it makes the pads respond very consistently regardless of where you strike them with the stick. The piezo elements are just lightly epoxied onto the back of the metal, and the edges are sealed with electrical tape."),Je=u(),Q=o("p"),os=i("After some quick testing with the scope, I confirmed that the pads did respond reasonably similarly to the commercial pad that I was using for the kick drum, but even having the bare pads just resting on the same surface would result in horrendous crosstalk between the pads. To try and prevent this from being a problem in the finished article, I used a much thicker foam mouse mat with sections removed to create floating supports for the pads. In retrospect I should have probably used softer foam, as crosstalk is still an issue, but the foam mount isolates the pads enough from one another to make the kit quite playable."),Xe=u(),Z=o("p"),ee=o("img"),Be=u(),te=o("p"),ns=i("Below is a quick video of the finished pads in action. I use both Hot Rods and regular sticks, and the difference is quite noticeable. The Hot Rods result in far less cross-talk, but it is hard to play quickly without some notes being dropped. In contrast, the regular sticks trigger much more relaibly, but I have to be quite careful to avoid neighbouring pads being triggered accidentally when playing!"),We=u(),P=o("p"),is=i("These pads are by no means a substitute for a real "),_e=o("em"),rs=i("SPD SX"),ls=i(", but for a hobbyist like me, they are great fun and can be built at a fraction of the price of the real deal!"),Ue=u(),cs(q.$$.fragment),this.h()},l(e){m=n(e,"P",{});var a=l(m);nt=r(a,"For a while I have window shopping for a drum sampling pad - in particular the ubiquitous "),oe=n(a,"EM",{});var Ds=l(oe);it=r(Ds,"Roland SPD SX"),Ds.forEach(t),rt=r(a,` (see picture below). However for the light use I will likely get out of a pad set, I can\u2019t really justify the high price for a proper set. So instead, I thought I\u2019d try to make my own!
These DIY drums don\u2019t have any form of sampling capabilities or sound-generation: they only output MIDI. This doesn\u2019t bother me, as all of my drum rack samples are generated in Ableton, however if you wanted to add inbuilt sampling/sound generation there are many Raspberry Pi based projects designed for this task. `),T=n(a,"A",{href:!0,rel:!0});var Ps=l(T);lt=r(Ps,"This one"),Ps.forEach(t),pt=r(a," is relatively straightforward to build and interface with a MIDI input."),a.forEach(t),De=h(e),H=n(e,"P",{});var Ts=l(H);x=n(Ts,"IMG",{src:!0,alt:!0}),Ts.forEach(t),Pe=h(e),f=n(e,"P",{});var se=l(f);ut=r(se,"The first and probably most crucial step of the E-Drum creation is to make the piezo pads themselves. There is a wealth of information on the subject online, however most of the similar builds that I found had the pads completely separate from one another. For an "),ne=n(se,"EM",{});var As=l(ne);ht=r(As,"SPD SX"),As.forEach(t),ct=r(se,"-style design with all the pads mounted on the same surface in close proximity to one another, crosstalk becomes a major concern. Diagnosing "),ie=n(se,"EM",{});var Ms=l(ie);dt=r(Ms,"crosstalk"),Ms.forEach(t),mt=r(se," through serial and MIDI messages is fairly tiresome, but thankfully I now have an oscilloscope! Below is a picture of me testing a commercial pad (origin unknown) against my homemade pads. Interestingly enough the Piezos behave quite differently when struck with Hot Rods compared to regular wooden sticks."),se.forEach(t),Te=h(e),$=n(e,"P",{});var Os=l($);F=n(Os,"IMG",{src:!0,alt:!0}),Os.forEach(t),Ae=h(e),k=n(e,"P",{});var Qe=l(k);ft=r(Qe,"The input that the STM32 \u2018sees\u2019 looks something like the oscilloscope capture shown below: Note that my hardware does not have any input filtering, only a 1M\u2126 resistor and a reverse-biased 3.3V zener diode across the output of each Piezo. The resistor helps clamp down the noise on the analogue input when the piezo is not struck , while the zener diode simply stops the voltage on the analog input straying outside "),re=n(Qe,"CODE",{});var Ss=l(re);gt=r(Ss,"-0.7V -> 3.3V"),Ss.forEach(t),bt=r(Qe,", protecting the microcontroller hardware. The lack of any filtering means two things:"),Qe.forEach(t),Me=h(e),v=n(e,"UL",{});var Ze=l(v);le=n(Ze,"LI",{});var Ls=l(le);kt=r(Ls,"We need to sample the input at a frequency that is an order of magnitude higher than the resonant freqency of the pads (this avoids missing the samples or recording inaccurate velocities)."),Ls.forEach(t),vt=h(Ze),pe=n(Ze,"LI",{});var qs=l(pe);yt=r(qs,"The peak detection has to be done in software, without misidentifying retriggers or \u2018ghost notes\u2019."),qs.forEach(t),Ze.forEach(t),Oe=h(e),y=n(e,"P",{});var et=l(y);wt=r(et,"The algorithm I used for processing the signal is very simple, and has plenty of room for optimisation, but it works surprisingly well. If you are interested in a superior hardware approach to processing the piezo signals, I would recommend reading "),A=n(et,"A",{href:!0,rel:!0});var Cs=l(A);_t=r(Cs,"this article"),Cs.forEach(t),It=r(et,"."),et.forEach(t),Se=h(e),G=n(e,"P",{});var Hs=l(G);Y=n(Hs,"IMG",{src:!0,alt:!0}),Hs.forEach(t),Le=h(e),w=n(e,"P",{});var tt=l(w);Et=r(tt,"The algorithm loops through each input, reading the analogue value to a variable called "),ue=n(tt,"CODE",{});var xs=l(ue);Dt=r(xs,"sample"),xs.forEach(t),Pt=r(tt,". Each input has 5 global variables (stored in an array):"),tt.forEach(t),qe=h(e),d=n(e,"UL",{});var b=l(d);z=n(b,"LI",{});var ps=l(z);he=n(ps,"CODE",{});var $s=l(he);Tt=r($s,"PAD_NOTES[10]"),$s.forEach(t),At=r(ps," - contains each input\u2019s MIDI note value."),ps.forEach(t),Mt=h(b),j=n(b,"LI",{});var us=l(j);ce=n(us,"CODE",{});var Fs=l(ce);Ot=r(Fs,"PAD_PINS[10]"),Fs.forEach(t),St=r(us," - contains the pin macro mapping the input to the physical pin that has to be read."),us.forEach(t),Lt=h(b),V=n(b,"LI",{});var hs=l(V);de=n(hs,"CODE",{});var Gs=l(de);qt=r(Gs,"PAD_ACTIVE[10]"),Gs.forEach(t),Ct=r(hs," - a boolean representing whether the input is \u2018ACTIVE\u2019 or not: (triggered when threshold is exceeded)."),hs.forEach(t),Ht=h(b),_=n(b,"LI",{});var Ie=l(_);me=n(Ie,"CODE",{});var Ys=l(me);xt=r(Ys,"PAD_SAMPLE_[10]"),Ys.forEach(t),$t=r(Ie," - a buffer of the previous "),fe=n(Ie,"CODE",{});var zs=l(fe);Ft=r(zs,"sample"),zs.forEach(t),Gt=r(Ie," value for each input."),Ie.forEach(t),Yt=h(b),I=n(b,"LI",{});var Ee=l(I);ge=n(Ee,"CODE",{});var js=l(ge);zt=r(js,"PAD_HOLDOFF[10]"),js.forEach(t),jt=r(Ee," - a timestamp (from "),be=n(Ee,"CODE",{});var Vs=l(be);Vt=r(Vs,"millis()"),Vs.forEach(t),Rt=r(Ee,") indicating when the input becomes \u2018ACTIVE\u2019."),Ee.forEach(t),b.forEach(t),Ce=h(e),E=n(e,"P",{});var st=l(E);Nt=r(st,"The processing is split into two stages: the first stage is to check when the input exceeds a certain \u2018Threshold\u2019. This threshold is globally defined and is set slightly higher than the noise floor of the piezos and any light crosstalk. Once a particular input exceeds this threshold, it is marked as \u2018ACTIVE\u2019, and the "),ke=n(st,"CODE",{});var Rs=l(ke);Jt=r(Rs,"PAD_HOLDOFF[i]"),Rs.forEach(t),Xt=r(st," is set as the current timestamp [see code snippet below]. However, the pad can\u2019t be set high unless a certain \u2018Holdoff\u2019 period has elapsed. This is a global variable that defines the minimum time between two consecutive triggers. It should be set short enough to allow for fast drum rolls, but long enough to prevent the trigger \u2018bouncing\u2019."),st.forEach(t),He=h(e),ds(M.$$.fragment,e),xe=h(e),O=n(e,"PRE",{class:!0});var ra=l(O);ra.forEach(t),$e=h(e),g=n(e,"P",{});var ae=l(g);Bt=r(ae,"Once the channel has been marked as active, we can\u2019t immediately send the MIDI note, as the sample that is measured when an input exceeds the \u2018Threshold\u2019 does not give us any real knowledge of the "),ve=n(ae,"EM",{});var Ns=l(ve);Wt=r(Ns,"velocity"),Ns.forEach(t),Ut=r(ae," of the drum strike. There are a multitude of methods of processing the input signal to derive a velocity, but the one I like the best is to wait until the most recent input sample is less than the previous sample (i.e. the first local peak has been reached). We then work out the velocity by multiplying the 12-bit anologue input value by 127 and divide through by the \u2018working range\u2019 of the ADC "),ye=n(ae,"EM",{});var Js=l(ye);Kt=r(Js,"(2^12 - Threshold)"),Js.forEach(t),Qt=r(ae,". This method doesn\u2019t work that well for really soft notes, but it doesn\u2019t involve any averaging or arbitrary delays, so the pads feel really responsive! The fact that the code in its entirety is not much more than these two snippets makes it quite easy to make a drum set with lots of pads and very low latency."),ae.forEach(t),Fe=h(e),ds(S.$$.fragment,e),Ge=h(e),L=n(e,"PRE",{class:!0});var la=l(L);la.forEach(t),Ye=h(e),R=n(e,"P",{});var Xs=l(R);N=n(Xs,"IMG",{src:!0,alt:!0}),Xs.forEach(t),ze=h(e),J=n(e,"P",{});var Bs=l(J);Zt=r(Bs,"The hardware (pictured above) is equally minimal. I was considering adding some LEDs and buttons to the unit, but considering it will never be more than 2 metres from my computer I decided against it. The drums have no onboard controls - everything is done over MIDI."),Bs.forEach(t),je=h(e),D=n(e,"P",{});var at=l(D);es=r(at,"The casing is actually a cut-down section of an old Strand LX analogue lighting console I managed to scavenge from a school clear-out. It is already shaped a bit like an "),we=n(at,"EM",{});var Ws=l(we);ts=r(Ws,"SPD SX"),Ws.forEach(t),ss=r(at,", and it is almost indestructible! It also has 1.6mm grooves built into the extrusion, so mounting my perfboard controller inside was a breeze. I added an extra serial header that outputs serial MIDI, in case I want to add a raspberry Pi as an onboard sound module at some point in the future."),at.forEach(t),Ve=h(e),X=n(e,"P",{});var Us=l(X);B=n(Us,"IMG",{src:!0,alt:!0}),Us.forEach(t),Re=h(e),W=n(e,"P",{});var Ks=l(W);U=n(Ks,"IMG",{src:!0,alt:!0}),Ks.forEach(t),Ne=h(e),K=n(e,"P",{});var Qs=l(K);as=r(Qs,"The pads are constructed from some scrap angle iron which have rubber/fabric mouse mats epoxied onto the top surface. The thicker-than-ideal metal makes the pads feel a bit less like a drum that I would have liked, but it makes the pads respond very consistently regardless of where you strike them with the stick. The piezo elements are just lightly epoxied onto the back of the metal, and the edges are sealed with electrical tape."),Qs.forEach(t),Je=h(e),Q=n(e,"P",{});var Zs=l(Q);os=r(Zs,"After some quick testing with the scope, I confirmed that the pads did respond reasonably similarly to the commercial pad that I was using for the kick drum, but even having the bare pads just resting on the same surface would result in horrendous crosstalk between the pads. To try and prevent this from being a problem in the finished article, I used a much thicker foam mouse mat with sections removed to create floating supports for the pads. In retrospect I should have probably used softer foam, as crosstalk is still an issue, but the foam mount isolates the pads enough from one another to make the kit quite playable."),Zs.forEach(t),Xe=h(e),Z=n(e,"P",{});var ea=l(Z);ee=n(ea,"IMG",{src:!0,alt:!0}),ea.forEach(t),Be=h(e),te=n(e,"P",{});var ta=l(te);ns=r(ta,"Below is a quick video of the finished pads in action. I use both Hot Rods and regular sticks, and the difference is quite noticeable. The Hot Rods result in far less cross-talk, but it is hard to play quickly without some notes being dropped. In contrast, the regular sticks trigger much more relaibly, but I have to be quite careful to avoid neighbouring pads being triggered accidentally when playing!"),ta.forEach(t),We=h(e),P=n(e,"P",{});var ot=l(P);is=r(ot,"These pads are by no means a substitute for a real "),_e=n(ot,"EM",{});var sa=l(_e);rs=r(sa,"SPD SX"),sa.forEach(t),ls=r(ot,", but for a hobbyist like me, they are great fun and can be built at a fraction of the price of the real deal!"),ot.forEach(t),Ue=h(e),ds(q.$$.fragment,e),this.h()},h(){c(T,"href","https://github.com/auscarpenter/pythonsamplesequencer"),c(T,"rel","nofollow"),C(x.src,ks="https://cdn.bojit.org/img/posts/DIY_E_Drums-Roland.JPG")||c(x,"src",ks),c(x,"alt","DIY_E_Drums-Roland.JPG"),C(F.src,vs="https://cdn.bojit.org/img/posts/DIY_E_Drums-Oscilloscope.JPG")||c(F,"src",vs),c(F,"alt","DIY_E_Drums-Oscilloscope.JPG"),c(A,"href","http://drummaster.digitalcave.ca/drummaster/design.jsp"),c(A,"rel","nofollow"),C(Y.src,ys="https://cdn.bojit.org/img/posts/DIY_E_Drums-Waveform.PNG")||c(Y,"src",ys),c(Y,"alt","DIY_E_Drums-Waveform.PNG"),c(O,"class","language-c"),c(L,"class","language-c"),C(N.src,ws="https://cdn.bojit.org/img/posts/DIY_E_Drums-Controller.JPG")||c(N,"src",ws),c(N,"alt","DIY_E_Drums-Controller.JPG"),C(B.src,_s="https://cdn.bojit.org/img/posts/DIY_E_Drums-Panels.JPG")||c(B,"src",_s),c(B,"alt","DIY_E_Drums-Panels.JPG"),C(U.src,Is="https://cdn.bojit.org/img/posts/DIY_E_Drums-Panels_2.JPG")||c(U,"src",Is),c(U,"alt","DIY_E_Drums-Panels_2.JPG"),C(ee.src,Es="https://cdn.bojit.org/img/posts/DIY_E_Drums-Shock_Mount.JPG")||c(ee,"src",Es),c(ee,"alt","DIY_E_Drums-Shock_Mount.JPG")},m(e,a){p(e,m,a),s(m,nt),s(m,oe),s(oe,it),s(m,rt),s(m,T),s(T,lt),s(m,pt),p(e,De,a),p(e,H,a),s(H,x),p(e,Pe,a),p(e,f,a),s(f,ut),s(f,ne),s(ne,ht),s(f,ct),s(f,ie),s(ie,dt),s(f,mt),p(e,Te,a),p(e,$,a),s($,F),p(e,Ae,a),p(e,k,a),s(k,ft),s(k,re),s(re,gt),s(k,bt),p(e,Me,a),p(e,v,a),s(v,le),s(le,kt),s(v,vt),s(v,pe),s(pe,yt),p(e,Oe,a),p(e,y,a),s(y,wt),s(y,A),s(A,_t),s(y,It),p(e,Se,a),p(e,G,a),s(G,Y),p(e,Le,a),p(e,w,a),s(w,Et),s(w,ue),s(ue,Dt),s(w,Pt),p(e,qe,a),p(e,d,a),s(d,z),s(z,he),s(he,Tt),s(z,At),s(d,Mt),s(d,j),s(j,ce),s(ce,Ot),s(j,St),s(d,Lt),s(d,V),s(V,de),s(de,qt),s(V,Ct),s(d,Ht),s(d,_),s(_,me),s(me,xt),s(_,$t),s(_,fe),s(fe,Ft),s(_,Gt),s(d,Yt),s(d,I),s(I,ge),s(ge,zt),s(I,jt),s(I,be),s(be,Vt),s(I,Rt),p(e,Ce,a),p(e,E,a),s(E,Nt),s(E,ke),s(ke,Jt),s(E,Xt),p(e,He,a),ms(M,e,a),p(e,xe,a),p(e,O,a),O.innerHTML=na,p(e,$e,a),p(e,g,a),s(g,Bt),s(g,ve),s(ve,Wt),s(g,Ut),s(g,ye),s(ye,Kt),s(g,Qt),p(e,Fe,a),ms(S,e,a),p(e,Ge,a),p(e,L,a),L.innerHTML=ia,p(e,Ye,a),p(e,R,a),s(R,N),p(e,ze,a),p(e,J,a),s(J,Zt),p(e,je,a),p(e,D,a),s(D,es),s(D,we),s(we,ts),s(D,ss),p(e,Ve,a),p(e,X,a),s(X,B),p(e,Re,a),p(e,W,a),s(W,U),p(e,Ne,a),p(e,K,a),s(K,as),p(e,Je,a),p(e,Q,a),s(Q,os),p(e,Xe,a),p(e,Z,a),s(Z,ee),p(e,Be,a),p(e,te,a),s(te,ns),p(e,We,a),p(e,P,a),s(P,is),s(P,_e),s(_e,rs),s(P,ls),p(e,Ue,a),ms(q,e,a),Ke=!0},p:ca,i(e){Ke||(fs(M.$$.fragment,e),fs(S.$$.fragment,e),fs(q.$$.fragment,e),Ke=!0)},o(e){gs(M.$$.fragment,e),gs(S.$$.fragment,e),gs(q.$$.fragment,e),Ke=!1},d(e){e&&t(m),e&&t(De),e&&t(H),e&&t(Pe),e&&t(f),e&&t(Te),e&&t($),e&&t(Ae),e&&t(k),e&&t(Me),e&&t(v),e&&t(Oe),e&&t(y),e&&t(Se),e&&t(G),e&&t(Le),e&&t(w),e&&t(qe),e&&t(d),e&&t(Ce),e&&t(E),e&&t(He),bs(M,e),e&&t(xe),e&&t(O),e&&t($e),e&&t(g),e&&t(Fe),bs(S,e),e&&t(Ge),e&&t(L),e&&t(Ye),e&&t(R),e&&t(ze),e&&t(J),e&&t(je),e&&t(D),e&&t(Ve),e&&t(X),e&&t(Re),e&&t(W),e&&t(Ne),e&&t(K),e&&t(Je),e&&t(Q),e&&t(Xe),e&&t(Z),e&&t(Be),e&&t(te),e&&t(We),e&&t(P),e&&t(Ue),bs(q,e)}}}const Ia={title:"DIY E-Drums",date:"16-05-2020",published:!0,tile:{type:"image",image:"/tiles/2020-05-16-DIY_E_Drums.PNG"}};class Ea extends pa{constructor(m){super(),ua(this,m,null,ma,ha,{})}}export{Ea as default,Ia as metadata};
