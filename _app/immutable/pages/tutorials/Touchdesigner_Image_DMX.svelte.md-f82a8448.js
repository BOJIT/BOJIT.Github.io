import{S as ko,i as Do,s as Po,e as n,t as a,k as y,c as s,a as r,h as i,d as o,m as v,b as c,U as W,g as d,K as e,E as Rt}from"../../chunks/index-cabb4aca.js";function Xo(Eo){let m,Ee,q,ke,De,Q,Pe,Xe,K,Ge,Oe,T,Ce,Ne,ue,E,k,At,fe,f,He,U,je,Re,M,Ae,Be,J,Fe,Se,ge,D,P,Bt,we,b,We,L,qe,Qe,z,Ke,Ue,ye,X,G,Ft,ve,g,Je,V,Le,ze,Y,Ve,Ye,Z,Ze,$e,be,O,C,St,_e,u,et,$,tt,ot,ee,at,it,te,nt,st,oe,rt,lt,ae,ht,dt,Ie,N,H,Wt,xe,h,pt,ie,ct,mt,ne,ut,ft,se,gt,wt,re,yt,vt,le,bt,_t,he,It,xt,de,Mt,Tt,pe,Et,kt,ce,Dt,Pt,me,Xt,Gt,Me,_,Ot,j,Ct,Nt,R,Ht,jt,Te,A,B,qt;return{c(){m=n("p"),Ee=a("For a recent theatre production I was involved in, I had to do some complex DMX pixel mapping as part of our lighting set. Normally I tackle most lighting programming with a program called MagicQ. The software is free and identical to the software used on professional Chamsys desks, but it does have its limitations. For one, the internal pixel mapping engine (pictured below) is not the greatest. It is usable for simple eye-candy effects with Sunstrips and LED battens, but for anything more exacting than that it is a pain to use. While you can get slightly more functionality by hooking MagicQ up to a media server, but in my opinion, it is better to completely bypass MagicQ and use something else as the pixel mapping engine. In my search for that \u2018something else\u2019, I came across "),q=n("em"),ke=a("Touchdesigner"),De=a(". While it is primarily a video manipulation tool, the sheer number of IO options in the software make it very flexible for all kinds of scripting/automation tasks. For the show I was working on, I used "),Q=n("em"),Pe=a("Touchdesigner"),Xe=a(" for more than just pixel-mapping, but in this article I will focus solely on how to create a simple Image->DMX pixel mapper in "),K=n("em"),Ge=a("Touchdesigner"),Oe=a(". To see what else I did with the software, read "),T=n("a"),Ce=a("this article"),Ne=a("."),ue=y(),E=n("p"),k=n("img"),fe=y(),f=n("p"),He=a("The method outlined here is far from the only way of pixel mapping in "),U=n("em"),je=a("Touchdesigner"),Re=a(". I have seen some very sophisticated 3D rendering engines and complex node systems for efficient GPU utilisation, and I would highly recommend taking a look at them, but this method is relatively simple to understand and modify, if you are a newbie like me. :) If you are looking for more information on how to make more complex rendering systems, I would encourage you to checkout "),M=n("a"),Ae=a("Matthew Wragan\u2019s website."),Be=a(`
To make `),J=n("em"),Fe=a("Touchdesigner"),Se=a(" networks easier to follow, I like to put all operators associated with one task in their own container. Not only does this neaten things up, it also makes it easier to share processing modules with other people as .tox files. Below you can see the inputs and outputs my pixel mapping engine takes: for inputs the container takes a video feed, an intensity slider and a washout/white slider; the outputs are the DMX channels and a preview of the pixel-mapped content. Only one input and output are really required, but having the preview window and the controls broken out makes troubleshooting and mapping controls to MIDI much easier."),ge=y(),D=n("p"),P=n("img"),we=y(),b=n("p"),We=a("Inside the container, the first group of operators simply handle video pre-processing. The video input is scaled to the aspect ratio of the pixel grid, then is "),L=n("em"),qe=a("multiplied"),Qe=a(" by the alpha value of a constant colour. The opacity of the constant colour is controlled by the \u2018intensity\u2019 slider input. This is a simple way of controlling the \u2018brightness\u2019 of the video input without changing the alpha values of the input, which is important later on. A similar operation is done with the "),z=n("em"),Ke=a("addition"),Ue=a(" of a constant colour, controlled by the \u2018washout/white\u2019 slider input. This is an equivalent of controlling the \u2018tint\u2019 of the image. Any other processing can be done after these operators, but if working with simple dimmers or RGB fixtures, it makes life easier to only apply effects to the RGB channels only and leave the Alpha channel alone."),ye=y(),X=n("p"),G=n("img"),ve=y(),g=n("p"),Je=a("Following this pre-processing, the video is scaled to the desired resolution of the pixel grid, then a "),V=n("em"),Le=a("TOPto->CHOP"),ze=a(" operator is used to turn each scan-line of the image into data channel. Following this conversion a "),Y=n("em"),Ve=a("Select"),Ye=a(" operator is used to filter all the red channels (using the r"),Z=n("em"),Ze=a("wildcard) from the image. If required, this CHOP can be directly manipulated to give the image data in a format that can be output over DMX, however we can deal with the data more intuitively by using a "),$e=a("CHOPto->DAT* operator to map every pixel value to a table. This table visually corresponds to the position of elements in the pixel grid, starting from top left and ending in the bottom right-hand corner. Note that for my project my pixel grid was made up of incandescent-style bulbs, so I only cared about the luminance of each pixel in the video feed, meaning it did not matter whether I looked at the R,G or B channel of the data. However if working with RGB fixtures we would need to have 3 separate tables for each colour channel."),be=y(),O=n("p"),C=n("img"),_e=y(),u=n("p"),et=a("Now that we have a nice grid of all our pixel values, we need to turn them into a format that our "),$=n("em"),tt=a("DMX"),ot=a(" operator can understand. In my case I was using an Entecc DMX-USB Pro as the physical DMX interface, but the operator also supports output over ArtNet. We need to map our data to a stream of 512 channels with values between 0 and 255. If you are working in 24 bit-per-pixel colour space (8 bits per channel), you probably already have the right range of values per DMX channel, so all we really need to do is map the value of each table cell to one of the 512 output channels. With the image data in DAT form this is relatively straightforward. The first step is to generate 512 empty channels. In "),ee=n("em"),at=a("Touchdesigner"),it=a(" there is a special syntax for doing this with a "),te=n("em"),nt=a("Constant"),st=a(" operator. Simply type "),oe=n("code"),rt=a("chan[1-512]"),lt=a(" into the first entry of the operator, and you\u2019re done! It is worth noting that while both "),ae=n("em"),ht=a("Touchdesigner"),dt=a(" and standard DMX work with DMX channels label DMX addresses 1-512, many computer processes and older lighting hardware work with addresses 0-511, so if you experience an \u2018out by one\u2019 error when doing fixture addressing, this may be why."),Ie=y(),N=n("p"),H=n("img"),xe=y(),h=n("p"),pt=a("To extract the pixel values in a logical order, we can use the "),ie=n("em"),ct=a("DATto->CHOP"),mt=a(" operator, using the settings pictured above. This will create channel names that start from 1, up to the number of cells in the table, with the numbers ascending left to right, top to bottom in the table. For monochrome grid systems, this is all the processing required, but for RGB systems all 3 tables must have their channel "),ne=n("em"),ut=a("names"),ft=a(" multiplied by 3 then offset by a specific amount. This data is in a format that can be fed directly into the "),se=n("em"),gt=a("DMX"),wt=a(" operator, but there is one remaining problem. The pixel grid we are using is not necessarily patched at address 1, so the channels need to be offset to the correct address. Note we are not adding an offset to the channel value, but to the channel names themselves. This is done with the "),re=n("em"),yt=a("Rename"),vt=a(" and "),le=n("em"),bt=a("Replace"),_t=a(" CHOPs. Say we wanted to patch a 6x6 grid starting at address 301, we would use the "),he=n("em"),It=a("Rename"),xt=a(" CHOP to map \u2019"),de=n("strong"),Mt=a("*"),Tt=a("\u2019 to "),pe=n("code"),Et=a("chan[301-336]"),kt=a(`, then replace the constant channels with our image pixel values in the main channel output. This arrangement is shown above.
This is the part of the pixel engine I am least pleased with, as the start address cannot be set with an external CHOP, and the `),ce=n("em"),Dt=a("Rename"),Pt=a(` CHOP does
not adapt to changes in the grid resolution. When I first made this system I was up against a show deadline, so left this annoyance in. If in the future
I design a better system, I will update this page and post the module as a `),me=n("code"),Xt=a(".tox"),Gt=a(" file."),Me=y(),_=n("p"),Ot=a("Below is a picture of the the core pixel mapping Touchdesigner network, and I have attached my Touchdesigner file "),j=n("a"),Ct=a("here"),Nt=a(", in case anyone finds it useful. There are numerous ways to enhance this system, but hopefully the information provided here will be useful if you are doing any projects with similar elements to this. Do check out the "),R=n("a"),Ht=a("project I used this pixel-mapper for"),jt=a(", which combines this pixel engine with lots of hanging light-bulbs and an Xbox Kinect!"),Te=y(),A=n("p"),B=n("img"),this.h()},l(t){m=s(t,"P",{});var l=r(m);Ee=i(l,"For a recent theatre production I was involved in, I had to do some complex DMX pixel mapping as part of our lighting set. Normally I tackle most lighting programming with a program called MagicQ. The software is free and identical to the software used on professional Chamsys desks, but it does have its limitations. For one, the internal pixel mapping engine (pictured below) is not the greatest. It is usable for simple eye-candy effects with Sunstrips and LED battens, but for anything more exacting than that it is a pain to use. While you can get slightly more functionality by hooking MagicQ up to a media server, but in my opinion, it is better to completely bypass MagicQ and use something else as the pixel mapping engine. In my search for that \u2018something else\u2019, I came across "),q=s(l,"EM",{});var Qt=r(q);ke=i(Qt,"Touchdesigner"),Qt.forEach(o),De=i(l,". While it is primarily a video manipulation tool, the sheer number of IO options in the software make it very flexible for all kinds of scripting/automation tasks. For the show I was working on, I used "),Q=s(l,"EM",{});var Kt=r(Q);Pe=i(Kt,"Touchdesigner"),Kt.forEach(o),Xe=i(l," for more than just pixel-mapping, but in this article I will focus solely on how to create a simple Image->DMX pixel mapper in "),K=s(l,"EM",{});var Ut=r(K);Ge=i(Ut,"Touchdesigner"),Ut.forEach(o),Oe=i(l,". To see what else I did with the software, read "),T=s(l,"A",{href:!0});var Jt=r(T);Ce=i(Jt,"this article"),Jt.forEach(o),Ne=i(l,"."),l.forEach(o),ue=v(t),E=s(t,"P",{});var Lt=r(E);k=s(Lt,"IMG",{src:!0,alt:!0}),Lt.forEach(o),fe=v(t),f=s(t,"P",{});var I=r(f);He=i(I,"The method outlined here is far from the only way of pixel mapping in "),U=s(I,"EM",{});var zt=r(U);je=i(zt,"Touchdesigner"),zt.forEach(o),Re=i(I,". I have seen some very sophisticated 3D rendering engines and complex node systems for efficient GPU utilisation, and I would highly recommend taking a look at them, but this method is relatively simple to understand and modify, if you are a newbie like me. :) If you are looking for more information on how to make more complex rendering systems, I would encourage you to checkout "),M=s(I,"A",{href:!0,rel:!0});var Vt=r(M);Ae=i(Vt,"Matthew Wragan\u2019s website."),Vt.forEach(o),Be=i(I,`
To make `),J=s(I,"EM",{});var Yt=r(J);Fe=i(Yt,"Touchdesigner"),Yt.forEach(o),Se=i(I," networks easier to follow, I like to put all operators associated with one task in their own container. Not only does this neaten things up, it also makes it easier to share processing modules with other people as .tox files. Below you can see the inputs and outputs my pixel mapping engine takes: for inputs the container takes a video feed, an intensity slider and a washout/white slider; the outputs are the DMX channels and a preview of the pixel-mapped content. Only one input and output are really required, but having the preview window and the controls broken out makes troubleshooting and mapping controls to MIDI much easier."),I.forEach(o),ge=v(t),D=s(t,"P",{});var Zt=r(D);P=s(Zt,"IMG",{src:!0,alt:!0}),Zt.forEach(o),we=v(t),b=s(t,"P",{});var F=r(b);We=i(F,"Inside the container, the first group of operators simply handle video pre-processing. The video input is scaled to the aspect ratio of the pixel grid, then is "),L=s(F,"EM",{});var $t=r(L);qe=i($t,"multiplied"),$t.forEach(o),Qe=i(F," by the alpha value of a constant colour. The opacity of the constant colour is controlled by the \u2018intensity\u2019 slider input. This is a simple way of controlling the \u2018brightness\u2019 of the video input without changing the alpha values of the input, which is important later on. A similar operation is done with the "),z=s(F,"EM",{});var eo=r(z);Ke=i(eo,"addition"),eo.forEach(o),Ue=i(F," of a constant colour, controlled by the \u2018washout/white\u2019 slider input. This is an equivalent of controlling the \u2018tint\u2019 of the image. Any other processing can be done after these operators, but if working with simple dimmers or RGB fixtures, it makes life easier to only apply effects to the RGB channels only and leave the Alpha channel alone."),F.forEach(o),ye=v(t),X=s(t,"P",{});var to=r(X);G=s(to,"IMG",{src:!0,alt:!0}),to.forEach(o),ve=v(t),g=s(t,"P",{});var x=r(g);Je=i(x,"Following this pre-processing, the video is scaled to the desired resolution of the pixel grid, then a "),V=s(x,"EM",{});var oo=r(V);Le=i(oo,"TOPto->CHOP"),oo.forEach(o),ze=i(x," operator is used to turn each scan-line of the image into data channel. Following this conversion a "),Y=s(x,"EM",{});var ao=r(Y);Ve=i(ao,"Select"),ao.forEach(o),Ye=i(x," operator is used to filter all the red channels (using the r"),Z=s(x,"EM",{});var io=r(Z);Ze=i(io,"wildcard) from the image. If required, this CHOP can be directly manipulated to give the image data in a format that can be output over DMX, however we can deal with the data more intuitively by using a "),io.forEach(o),$e=i(x,"CHOPto->DAT* operator to map every pixel value to a table. This table visually corresponds to the position of elements in the pixel grid, starting from top left and ending in the bottom right-hand corner. Note that for my project my pixel grid was made up of incandescent-style bulbs, so I only cared about the luminance of each pixel in the video feed, meaning it did not matter whether I looked at the R,G or B channel of the data. However if working with RGB fixtures we would need to have 3 separate tables for each colour channel."),x.forEach(o),be=v(t),O=s(t,"P",{});var no=r(O);C=s(no,"IMG",{src:!0,alt:!0}),no.forEach(o),_e=v(t),u=s(t,"P",{});var w=r(u);et=i(w,"Now that we have a nice grid of all our pixel values, we need to turn them into a format that our "),$=s(w,"EM",{});var so=r($);tt=i(so,"DMX"),so.forEach(o),ot=i(w," operator can understand. In my case I was using an Entecc DMX-USB Pro as the physical DMX interface, but the operator also supports output over ArtNet. We need to map our data to a stream of 512 channels with values between 0 and 255. If you are working in 24 bit-per-pixel colour space (8 bits per channel), you probably already have the right range of values per DMX channel, so all we really need to do is map the value of each table cell to one of the 512 output channels. With the image data in DAT form this is relatively straightforward. The first step is to generate 512 empty channels. In "),ee=s(w,"EM",{});var ro=r(ee);at=i(ro,"Touchdesigner"),ro.forEach(o),it=i(w," there is a special syntax for doing this with a "),te=s(w,"EM",{});var lo=r(te);nt=i(lo,"Constant"),lo.forEach(o),st=i(w," operator. Simply type "),oe=s(w,"CODE",{});var ho=r(oe);rt=i(ho,"chan[1-512]"),ho.forEach(o),lt=i(w," into the first entry of the operator, and you\u2019re done! It is worth noting that while both "),ae=s(w,"EM",{});var po=r(ae);ht=i(po,"Touchdesigner"),po.forEach(o),dt=i(w," and standard DMX work with DMX channels label DMX addresses 1-512, many computer processes and older lighting hardware work with addresses 0-511, so if you experience an \u2018out by one\u2019 error when doing fixture addressing, this may be why."),w.forEach(o),Ie=v(t),N=s(t,"P",{});var co=r(N);H=s(co,"IMG",{src:!0,alt:!0}),co.forEach(o),xe=v(t),h=s(t,"P",{});var p=r(h);pt=i(p,"To extract the pixel values in a logical order, we can use the "),ie=s(p,"EM",{});var mo=r(ie);ct=i(mo,"DATto->CHOP"),mo.forEach(o),mt=i(p," operator, using the settings pictured above. This will create channel names that start from 1, up to the number of cells in the table, with the numbers ascending left to right, top to bottom in the table. For monochrome grid systems, this is all the processing required, but for RGB systems all 3 tables must have their channel "),ne=s(p,"EM",{});var uo=r(ne);ut=i(uo,"names"),uo.forEach(o),ft=i(p," multiplied by 3 then offset by a specific amount. This data is in a format that can be fed directly into the "),se=s(p,"EM",{});var fo=r(se);gt=i(fo,"DMX"),fo.forEach(o),wt=i(p," operator, but there is one remaining problem. The pixel grid we are using is not necessarily patched at address 1, so the channels need to be offset to the correct address. Note we are not adding an offset to the channel value, but to the channel names themselves. This is done with the "),re=s(p,"EM",{});var go=r(re);yt=i(go,"Rename"),go.forEach(o),vt=i(p," and "),le=s(p,"EM",{});var wo=r(le);bt=i(wo,"Replace"),wo.forEach(o),_t=i(p," CHOPs. Say we wanted to patch a 6x6 grid starting at address 301, we would use the "),he=s(p,"EM",{});var yo=r(he);It=i(yo,"Rename"),yo.forEach(o),xt=i(p," CHOP to map \u2019"),de=s(p,"STRONG",{});var vo=r(de);Mt=i(vo,"*"),vo.forEach(o),Tt=i(p,"\u2019 to "),pe=s(p,"CODE",{});var bo=r(pe);Et=i(bo,"chan[301-336]"),bo.forEach(o),kt=i(p,`, then replace the constant channels with our image pixel values in the main channel output. This arrangement is shown above.
This is the part of the pixel engine I am least pleased with, as the start address cannot be set with an external CHOP, and the `),ce=s(p,"EM",{});var _o=r(ce);Dt=i(_o,"Rename"),_o.forEach(o),Pt=i(p,` CHOP does
not adapt to changes in the grid resolution. When I first made this system I was up against a show deadline, so left this annoyance in. If in the future
I design a better system, I will update this page and post the module as a `),me=s(p,"CODE",{});var Io=r(me);Xt=i(Io,".tox"),Io.forEach(o),Gt=i(p," file."),p.forEach(o),Me=v(t),_=s(t,"P",{});var S=r(_);Ot=i(S,"Below is a picture of the the core pixel mapping Touchdesigner network, and I have attached my Touchdesigner file "),j=s(S,"A",{href:!0});var xo=r(j);Ct=i(xo,"here"),xo.forEach(o),Nt=i(S,", in case anyone finds it useful. There are numerous ways to enhance this system, but hopefully the information provided here will be useful if you are doing any projects with similar elements to this. Do check out the "),R=s(S,"A",{href:!0});var Mo=r(R);Ht=i(Mo,"project I used this pixel-mapper for"),Mo.forEach(o),jt=i(S,", which combines this pixel engine with lots of hanging light-bulbs and an Xbox Kinect!"),S.forEach(o),Te=v(t),A=s(t,"P",{});var To=r(A);B=s(To,"IMG",{src:!0,alt:!0}),To.forEach(o),this.h()},h(){c(T,"href","https://bojit.org/projects/Kinect_Interactive_Grid"),W(k.src,At="https://cdn.bojit.org/img/posts/Touchdesigner_Image_DMX-MagicQ.PNG")||c(k,"src",At),c(k,"alt","Touchdesigner_Image_DMX-MagicQ.PNG"),c(M,"href","https://matthewragan.com/teaching-resources/touchdesigner/"),c(M,"rel","nofollow"),W(P.src,Bt="https://cdn.bojit.org/img/posts/Touchdesigner_Image_DMX-Input_Module.JPG")||c(P,"src",Bt),c(P,"alt","Touchdesigner_Image_DMX-Input_Module.JPG"),W(G.src,Ft="https://cdn.bojit.org/img/posts/Touchdesigner_Image_DMX-Input_Filtering.PNG")||c(G,"src",Ft),c(G,"alt","Touchdesigner_Image_DMX-Input_Filtering.PNG"),W(C.src,St="https://cdn.bojit.org/img/posts/Touchdesigner_Image_DMX-TOPto_CHOP.PNG")||c(C,"src",St),c(C,"alt","Touchdesigner_Image_DMX-TOPto_CHOP.PNG"),W(H.src,Wt="https://cdn.bojit.org/img/posts/Touchdesigner_Image_DMX-Output_Processing.PNG")||c(H,"src",Wt),c(H,"alt","Touchdesigner_Image_DMX-Output_Processing.PNG"),c(j,"href","https://cdn.bojit.org/files/2019-03-31-Touchdesigner_Image_DMX-Example.toe"),c(R,"href","https://bojit.org/projects/Kinect_Interactive_Grid"),W(B.src,qt="https://cdn.bojit.org/img/posts/Touchdesigner_Image_DMX-Nodes.PNG")||c(B,"src",qt),c(B,"alt","Touchdesigner_Image_DMX-Nodes.PNG")},m(t,l){d(t,m,l),e(m,Ee),e(m,q),e(q,ke),e(m,De),e(m,Q),e(Q,Pe),e(m,Xe),e(m,K),e(K,Ge),e(m,Oe),e(m,T),e(T,Ce),e(m,Ne),d(t,ue,l),d(t,E,l),e(E,k),d(t,fe,l),d(t,f,l),e(f,He),e(f,U),e(U,je),e(f,Re),e(f,M),e(M,Ae),e(f,Be),e(f,J),e(J,Fe),e(f,Se),d(t,ge,l),d(t,D,l),e(D,P),d(t,we,l),d(t,b,l),e(b,We),e(b,L),e(L,qe),e(b,Qe),e(b,z),e(z,Ke),e(b,Ue),d(t,ye,l),d(t,X,l),e(X,G),d(t,ve,l),d(t,g,l),e(g,Je),e(g,V),e(V,Le),e(g,ze),e(g,Y),e(Y,Ve),e(g,Ye),e(g,Z),e(Z,Ze),e(g,$e),d(t,be,l),d(t,O,l),e(O,C),d(t,_e,l),d(t,u,l),e(u,et),e(u,$),e($,tt),e(u,ot),e(u,ee),e(ee,at),e(u,it),e(u,te),e(te,nt),e(u,st),e(u,oe),e(oe,rt),e(u,lt),e(u,ae),e(ae,ht),e(u,dt),d(t,Ie,l),d(t,N,l),e(N,H),d(t,xe,l),d(t,h,l),e(h,pt),e(h,ie),e(ie,ct),e(h,mt),e(h,ne),e(ne,ut),e(h,ft),e(h,se),e(se,gt),e(h,wt),e(h,re),e(re,yt),e(h,vt),e(h,le),e(le,bt),e(h,_t),e(h,he),e(he,It),e(h,xt),e(h,de),e(de,Mt),e(h,Tt),e(h,pe),e(pe,Et),e(h,kt),e(h,ce),e(ce,Dt),e(h,Pt),e(h,me),e(me,Xt),e(h,Gt),d(t,Me,l),d(t,_,l),e(_,Ot),e(_,j),e(j,Ct),e(_,Nt),e(_,R),e(R,Ht),e(_,jt),d(t,Te,l),d(t,A,l),e(A,B)},p:Rt,i:Rt,o:Rt,d(t){t&&o(m),t&&o(ue),t&&o(E),t&&o(fe),t&&o(f),t&&o(ge),t&&o(D),t&&o(we),t&&o(b),t&&o(ye),t&&o(X),t&&o(ve),t&&o(g),t&&o(be),t&&o(O),t&&o(_e),t&&o(u),t&&o(Ie),t&&o(N),t&&o(xe),t&&o(h),t&&o(Me),t&&o(_),t&&o(Te),t&&o(A)}}}const Oo={title:"Touchdesigner: Image -> DMX",date:"31-03-2019",published:!0,tile:{type:"link",colour:"#87CEEB"}};class Co extends ko{constructor(m){super(),Do(this,m,null,Xo,Po,{})}}export{Co as default,Oo as metadata};
